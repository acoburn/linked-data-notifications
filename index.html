<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta charset="utf-8" />
        <title>Linked Data Notifications</title>
        <meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="https://dokie.li/media/css/basic.css" media="all" rel="stylesheet alternate" title="Basic" />
        <link href="https://dokie.li/media/css/lncs.css" media="all" rel="stylesheet" title="LNCS" />
        <link href="https://dokie.li/media/css/acm.css" media="all" rel="stylesheet alternate" title="ACM" />
        <link href="https://www.w3.org/StyleSheets/TR/2016/W3C-UD" media="all" rel="stylesheet alternate" title="W3C-UD" />
        <link href="https://dokie.li/media/css/do.css" media="all" rel="stylesheet" />
        <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" media="all" rel="stylesheet" />
        <link href="https://dokie.li/media/css/editor.css" media="all" rel="stylesheet" />
        <script src="https://dokie.li/scripts/simplerdf.js"></script>
        <script src="https://dokie.li/scripts/medium-editor.min.js"></script>
        <script src="https://dokie.li/scripts/medium-editor-tables.min.js"></script>
        <script src="https://dokie.li/scripts/do.js"></script>
    </head>

    <body about="" prefix="rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# rdfs: http://www.w3.org/2000/01/rdf-schema# owl: http://www.w3.org/2002/07/owl# xsd: http://www.w3.org/2001/XMLSchema# dcterms: http://purl.org/dc/terms/ dctypes: http://purl.org/dc/dcmitype/ foaf: http://xmlns.com/foaf/0.1/ v: http://www.w3.org/2006/vcard/ns# pimspace: http://www.w3.org/ns/pim/space# cc: http://creativecommons.org/ns# skos: http://www.w3.org/2004/02/skos/core# prov: http://www.w3.org/ns/prov# qb: http://purl.org/linked-data/cube# schema: http://schema.org/ rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# cal: http://www.w3.org/2002/12/cal/ical# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# org: http://www.w3.org/ns/org# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ sioc: http://rdfs.org/sioc/ns# doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ oa: http://www.w3.org/ns/oa# as: http://www.w3.org/ns/activitystreams# ldp: http://www.w3.org/ns/ldp# solid: http://www.w3.org/ns/solid/terms#" typeof="schema:CreativeWork sioc:Post prov:Entity">
        <main>
            <article about="" typeof="schema:Article">
                <h1 property="schema:name">Linked Data Notifications</h1>

                <div id="authors">
                    <dl id="author-name">
                        <dt>Authors</dt>
                        <dd id="Sarven-Capadisli" inlist="" rel="bibo:authorList" resource="http://csarven.ca/#i"><span about="" rel="schema:contributor schema:creator schema:publisher schema:author"><span about="http://csarven.ca/#i" typeof="schema:Person"><a href="http://csarven.ca/" rel="schema:url"><span about="http://csarven.ca/#i" property="schema:name"><span property="schema:givenName">Sarven</span> <span property="schema:familyName">Capadisli</span></span></a></span></span><sup><a about="http://csarven.ca/#i" href="#author-org-1" rel="schema:memberOf" resource="http://dbpedia.org/resource/University_of_Bonn">1</a></sup><sup><a href="#author-email-1">‚úä</a></sup></dd>
                        <dd id="Amy-Guy" inlist="" rel="bibo:authorList" resource="http://rhiaro.co.uk/about#me"><span about="" rel="schema:creator schema:author"><span about="http://rhiaro.co.uk/#me" typeof="schema:Person"><a href="http://rhiaro.co.uk/" rel="schema:url"><span about="http://rhiaro.co.uk/#me" property="schema:name"><span property="schema:givenName">Amy</span> <span property="schema:familyName">Guy</span></span></a></span></span><sup><a about="http://rhiaro.co.uk/about#me" href="#author-org-2" rel="schema:memberOf" resource="http://dbpedia.org/resource/University_of_Edinburgh">2</a></sup><sup><a href="#author-email-2">üê¶</a></sup></dd>
                        <dd id="Christoph-Lange" inlist="" rel="bibo:authorList" resource="http://eis.iai.uni-bonn.de/ChristophLange"><span about="" rel="schema:contributor"><a about="http://eis.iai.uni-bonn.de/ChristophLange" href="https://langec.wordpress.com/about/" property="schema:name" rel="schema:url" typeof="schema:Person">Christoph Lange</a></span><sup><a about="http://eis.iai.uni-bonn.de/ChristophLange" href="#author-org-1" rel="schema:memberOf" resource="http://dbpedia.org/resource/University_of_Bonn">1</a></sup><sup><a href="#author-email-3">‚à´</a></sup></dd>
                        <dd id="S√∂ren-Auer" inlist="" rel="bibo:authorList" resource="http://eis.iai.uni-bonn.de/SoerenAuer"><span about="" rel="schema:contributor"><a about="http://eis.iai.uni-bonn.de/SoerenAuer" href="http://eis.iai.uni-bonn.de/SoerenAuer.html" property="schema:name" rel="schema:url" typeof="schema:Person">S√∂ren Auer</a></span><sup><a about="http://eis.iai.uni-bonn.de/SoerenAuer" href="#author-org-1" rel="schema:memberOf" resource="http://dbpedia.org/resource/University_of_Bonn">1</a></sup><sup><a href="#author-email-4">‚öõ</a></sup></dd>
                    </dl>

                    <ul id="author-org">
                        <li id="author-org-1"><sup>1</sup>Enterprise Information Systems Department, <a about="http://dbpedia.org/resource/University_of_Bonn" href="http://uni-bonn.de/" property="schema:name" rel="schema:url" typeof="schema:Organization">University of Bonn</a>, Bonn, Germany</li>
                        <li id="author-org-2"><sup>2</sup>School of Informatics, <a about="http://dbpedia.org/resource/University_of_Edinburgh" href="http://inf.ed.ac.uk/" property="schema:name" rel="schema:url" typeof="schema:Organization">University of Edinburgh</a>, Edinburgh, UK</li>
                    </ul>

                    <ul id="author-email">
                        <li id="author-email-1"><sup>‚úä</sup><a about="http://csarven.ca/#i" href="mailto:info@csarven.ca" rel="schema:email">info@csarven.ca</a></li>
                        <li id="author-email-2"><sup>üê¶</sup><a about="http://rhiaro.co.uk/about#me" href="mailto:amy@rhiaro.co.uk" rel="schema:email">amy@rhiaro.co.uk</a></li>
                        <li id="author-email-3"><sup>‚à´</sup><a about="http://eis.iai.uni-bonn.de/ChristophLange" href="mailto:langec@cs.uni-bonn.de" rel="schema:email">langec@cs.uni-bonn.de</a></li>
                        <li id="author-email-4"><sup>‚öõ</sup><a about="http://eis.iai.uni-bonn.de/SoerenAuer" href="mailto:auer@cs.uni-bonn.de" rel="schema:email">auer@cs.uni-bonn.de</a></li>
                    </ul>
                </div>

                <dl id="document-identifier">
                    <dt>Identifier</dt>
                    <dd><a href="http://csarven.ca/linked-data-notifications" rel="owl:sameAs">http://csarven.ca/linked-data-notifications</a></dd>
                </dl>

                <dl id="document-in-reply-to">
                    <dt>In Reply To</dt>
                    <dd><a href="http://2017.eswc-conferences.org/call-papers" rel="sioc:reply_of">ESWC 2017 Call for Papers</a></dd>
                </dl>

                <dl id="document-published">
                    <dt>Published</dt>
                    <dd><time datatype="xsd:dateTime" datetime="2016-05-01T00:00:00Z" property="schema:datePublished">2016-05-01</time></dd>
                </dl>

                <dl id="document-modified">
                    <dt>Modified</dt>
                    <dd><time datatype="xsd:dateTime" datetime="2016-12-09T00:00:00Z" property="schema:dateModified">2016-12-09</time></dd>
                </dl>

                <dl id="document-license">
                    <dt>License</dt>
                    <dd><a href="https://creativecommons.org/licenses/by/4.0/" rel="schema:license" title="Creative Commons Attribution 4.0 Unported">CC BY 4.0</a></dd>
                </dl>

                <div id="content">
                    <section id="abstract">
                        <h2>Abstract</h2>
                        <div datatype="rdf:HTML" property="schema:abstract">
                          <p>Notifications are sent over the Web for a variety of purposes, for example, by social applications. 
						  The data contained within a notification is arbitrary, and typically only usable by the application which generated it in the first place. 
						  In the spirit of Linked Data, we propose that notifications should be reusable by multiple applications. 
						  This provides end users more freedom to switch between the online tools they use, as well as generating greater value when notifications from different sources can be used in combination. 
						  Through separating the concepts of <em>senders</em>, <em>receivers</em> and <em>consumers</em> of notifications, and leveraging Linked Data principles of shared vocabularies and URIs references, the Linked Data Notifications (LDN) protocol meets this goal. 
						  In this article we describe the protocol, which is a Candidate Recommendation of the W3C (<a href="https://www.w3.org/TR/ldn/">https://www.w3.org/TR/ldn/</a>), situate it alongside related initiatives, and discuss additional considerations such as the decoupling of applications from data storage. 
						  We evaluate the protocol's effectiveness with multiple, independent implementations which pass a suite of formal tests and can be demonstrated interoperating with each other. 
						  The canonical URI of this article is http://csarven.ca/linked-data-notifications</p>
                        </div>
                    </section>

                    <section id="keywords">
                        <h2>Keywords</h2>
                        <div>
                            <ul rel="schema:about">
                                <li><a href="https://en.wikipedia.org/wiki/Communications_protocol" resource="http://dbpedia.org/resource/Communications_protocol">Communications protocol</a></li>
                                <li><a href="https://en.wikipedia.org/wiki/Decentralization" resource="http://dbpedia.org/resource/Decentralization">Decentralisation</a></li>
                                <li><a href="https://en.wikipedia.org/wiki/Linked_data" resource="http://dbpedia.org/resource/Linked_data">Linked Data</a></li>
                                <li><a href="https://en.wikipedia.org/wiki/Social_web" resource="http://dbpedia.org/resource/Social_web">Social web</a></li>
                            </ul>
                        </div>
                    </section>

                    <section id="introduction" inlist="" rel="schema:hasPart" resource="#introduction">
                        <h2 property="schema:name">Introduction</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>In a decentralized architecture, such as the World Wide Web, notifications are a crucial element for information and application integration.
							Notifications are sent over the Web for a variety of purposes, including social applications. <span class="todo">put some specific, vivid examples here</span> 
							The notification data may be displayed to a human to acknowledge, or used to trigger some other application-specific process (or both). 
							This data is arbitrary and typically only usable by the application which generated it in the first place. 
							Current efforts towards <em>re-decentralising</em> the Web [http://crosscloud.org/2016/www-mansour-pdf.pdf, http://www.semantic-web-journal.net/sites/default/files/swj201_4.pdf, https://unhosted.org/, cite] are moving towards architectures in which data storage is decoupled from application logic, freeing end users from switch between applications, or to let multiple applications operate over the same data. 
							So far, notifications are considered to be <em>ephemeral</em> resources which may disappear after transport, and thus are excluded from being reusable data.</p>

                            <p>We deem that notification data should not be locked within particular systems and designed the protocol <em>Linked Data Notifications (LDN)</em> to support sharing and reuse of notifications <em>across</em> applications, regardless of how they were generated or what their contents are. 
							We describe how the principles of identification, addressability and semantic representation can be applied to notifications on the Web.
							Specifying LDN as a formal protocol allows independently implemented, heterogeneous applications which generate and use notifications, to seamlessly work together. 
							Thus, LDN supports the decentralisation of the Web as well as encourages the generation and consumption of Linked Data.</p>

                            <p>We build on existing W3C standards and Linked Data principles. 
							In particular, the storage of notifications is compatible with the <cite>Linked Data Platform</cite> standard, notifications are identified by HTTP URIs, and notification contents must be available as JSON-LD (optionally negotiated for other RDF serialisations).
							A key architectural decision is the separation of concerns between <em>senders</em>, <em>receivers</em>, and <em>consumers</em> of notifications. 
							Implementations of the protocol can play one or more of these roles, and interoperate successfully with implementations playing the complementary roles. 
							This means that notifications generated by one application can be reused by a completely different application, employing shared Linked Data vocabularies, and accessed via the store where the notification data resides.</p>

                            <p>LDN is a Candidate <a href="https://www.w3.org/TR/ldn/">Recommendation</a> of the W3C, and incorporated in <cite><a href="https://www.w3.org/TR/activitypub/">ActivityPub</a></cite>, a W3C Candidate Recommendation for decentralised social networking protocol based upon the <cite>ActivityStreams 2.0</cite> data format.</p>

                            <p>In this article we present use cases for decentralised notifications from the Social Web domain, and describe the requirements which guided the development of the protocol. 
							We discuss related work in terms of predecessors to this work, comparisons with current alternative approaches, as well as complementary protocols which can work alongside LDN. 
							We summarise the protocol itself, and then go into detail about specific architectural considerations that were made. We built a test suite which can be used to confirm that implementations conform with the specification, and we describe the independent implementations which interoperate with each other so far.</p>

                            <div about="" id="concept-scheme" rel="schema:hasPart" resource="#concept-scheme">
                                <p resource="#concept-scheme" typeof="skos:ConceptScheme"><span property="skos:prefLabel">We use some terms throughout which may be subject to different interpretations by different communities, so we provide some definitions here.</span></p>

                                <dl rel="skos:hasTopConcept">
                                    <dt about="#concept-decentralisation" id="concept-decentralisation" property="skos:prefLabel" rel="skos:topConceptOf" resource="#concept-scheme" typeof="skos:Concept">Decentralisation</dt>
                                    <dd about="#concept-decentralisation" property="skos:definition">Data and applications are loosely coupled, and users are empowered to choose where their data is stored or held. 
									We focus on Web-based decentralisation, where content is transported over HTTP, and resources are identified with URIs.</dd>

                                    <dt about="#concept-inbox" id="concept-inbox" property="skos:prefLabel" rel="skos:topConceptOf" resource="#concept-scheme" typeof="skos:Concept">Inbox</dt>
                                    <dd about="#concept-inbox" property="skos:definition">A container or directory (attached to a Web resource) which is used to store and serve a collection of notifications.</dd>

                                    <dt about="#concept-notification" id="concept-notification" property="skos:prefLabel" rel="skos:topConceptOf" resource="#concept-scheme" typeof="skos:Concept">Notification</dt>
                                    <dd about="#concept-notification" property="skos:definition">A retrievable resource which returns RDF. 
									The contents of notifications are intended to describe a change in state of some other resource, or contain new information for the attention of a user or process, and may be subject to constraints of the Inbox it is contained in.</dd>
                                </dl>
                            </div>

                            <p>Using this article as the target for notifications, we welcome your feedback.</p>
                        </div>
                    </section>          


                    <section id="use-cases" inlist="" rel="schema:hasPart" resource="#use-cases">
                        <h2 property="schema:name">Use cases</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>The high level use case is to have independently built applications to be able to generate and make use of notification data no matter how it was created or where it is stored. 
							Here we briefly discuss some of the use cases from different domains that can make use of Linked Data Notifications.</p>

                            <p><strong>Social</strong>: Announcements of new status updates and blog posts from contacts can be delivered through notifications; private and public personal messages; new comments or annotations on content as well as likes, shares, and bookmarks; invitations to events, and RSVPs.
							In particular for connecting different social networks or for realizing a fully distributed social network, standardized and semantically represented notifications are absolutely essential.</p>

                            <p><strong>Scholarly Communication</strong>: Academic articles, scientific reports, and their peer-reviews can be published online. 
							Notifications can inform the author of an academic article or the scientific community about a new review or contribution. 
							For example, the notification can contain a concise description about what was reviewed and where the source can be found, when it was created, by whom, and the conditions under which it can be reused.
							Another use case for scholarly articles would be to notify an author when their work has been cited, in order to provide the means to build bidirectional connections between ideas, discoveries, and innovations, as well as their evolution.</p>

                            <p><strong>Change of State</strong>: Notifications can be used to capture provenance and state changes. 
							For instance, datasets have changesets which include deltas between resources; software or collaborative documents have versioning; applications detect dataset issues and recommend fixes; emergency broadcasts are made during disaster situations; weather forecasts; personal fitness states; or scientific, experimental and statistical observations.
							For example, notifications can be used to disseminate scientific observations captured by systems, devices or sensors (e.g. telescope imagery, weather data) in a tailored and targeted manner to interested peer researchers. 
							Applications can customise the notification to contain a small, semantically represented unit of information capturing in particular the time and state of an event.</p>
                        </div>
                    </section>


                    <section id="related-work" inlist="" rel="schema:hasPart" resource="#related-work">
                        <h2 property="schema:name">Related Work</h2>
                        <div datatype="rdf:HTML" property="schema:description" resource="#related-work" typeof="deo:RelatedWork">

                            <section id="notification-mechanisms" rel="schema:hasPart" resource="#notification-mechanisms">
                                <h3 property="schema:name">Notification mechanisms</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>Here we review previous and ongoing efforts towards delivering notifications in a decentralised manner. Since many systems which make use of notifications operate either in a completely centralised way, or are decentralised only in the sense that different instances of the <em>same</em> codebase need to interoperate, there appears to be limited work to review.</p>

                                    <p>The contents of a notification is one of either: 1) URLs, indicating relations between Web resources, or 2) a 'fat ping' containing a blob of information. Semantic Pingback, Webmention, and Provenance Pingback follow the first form, and are also known as <cite>linkbacks</cite>, the suite of protocols that essentially allows Web documents to manually and automatically link to or mention one another. This has the advantage that a verification mechanism can be tightly specified (the URL of the target must appear in the content of the source), but the disadvantage that notifications are only available for the use case of a link being published on the Web.</p>

                                    <p><strong>Semantic Pingback</strong> [<a href="http://www.informatik.uni-leipzig.de/~auer/publication/SemanticPingback.pdf"></a>, <a href="https://www.w3.org/wiki/index.php?title=Pingback&amp;oldid=57876"></a>, <a href="https://aksw.github.io/SemanticPingback/"></a>] and <strong>Webmention</strong> [<a href="https://www.w3.org/TR/webmention"></a>] both update the original Pingback [<a href="http://www.hixie.ch/specs/pingback/pingback"></a>] mechanism by replacing the XML-RPC transport mechanism by a <code>x-www-form-urlencoded</code> request with two parameters (<code>source</code> and <code>target</code>). They both also replace the <code>X-Pingback</code> HTTP header with a <code>Link</code> relation, either in HTTP or HTML, for discovery of the respective receiving service. Semantic Pingback further enables discovery of the Pingback service where source resources are available as RDF. While the content at source may indicate (in any convention or serialisation format) the type of relation between the source and target URLs, the information about the relation is not transmitted to the receiver's endpoint, and nor is there a way to distinguish between multiple potential mentions of the target; this is left up to the receiver to interpret. Semantic Pingback does encourage generation of additional semantics about the relation(s) between the source and the target by processing the source as RDF if possible, and also defines specific ways for a receiving server to handle incoming pingback data in order to add the source data to an RDF knowledge base. Beyond verification, Webmention does not specify any further requirements of the receiving server; it is not expected that "mentions" are retrievable once they have been sent. </p>

                                    <!--- we probably don't need this exact paragraph, but want to include all these implementation refs somewhere
                                    <p>Semantic Pingback was implemented into OntoWiki [http://www.semantic-web-journal.net/sites/default/files/swj201_4.pdf] and as part of the <em>Structured Feedback</em> suite of tools [http://events.linkeddata.org/ldow2016/papers/LDOW2016_paper_02.pdf]. Webmention senders and receivers have been independently implemented as part of libraries, into blogging platforms such as Wordpress and Known, and as part of several personal websites or blogs [https://webmention.net/implementation-reports/summary/].</p>-->

                                    <p id="provenance-pingback">A <strong>Provenance Pingback</strong> endpoint is also advertised through an HTTP Link header, and accepts a list of URIs for provenance records describing uses of the resource [<a href="http://www.w3.org/TR/prov-aq/#provenance-pingback"></a>]. Provenance Pingback does not specify any further behaviour by the receiving server, but the contents of the URIs listed in the notification body are well-defined.</p>

                                    <p>There are also notification mechanisms which send more information than just URLs in the notification body; due to each mechanism's focused use case, the payload is restricted to a particular vocabulary.</p>

                                    <p><strong>DSNotify</strong> is a centralised service which crawls Linked Datasets and tracks changes to links (create, remove, move, update) with the specific use case of preserving link integrity between Linked Open Data resources. Notifications of changes are delivered to subscribers in the form of a specific XML payload [<a href="http://eprints.cs.univie.ac.at/81/1/2010_WWW_DSNotify.pdf"></a>, <a href="http://www.cibiv.at/~niko/dsnotify/"></a>]. Alternatively, with the <strong>sparqlPuSH</strong> service, users may indicate specific updates to a dataset they are interested in via a SPARQL query. The query is run periodically by the service, and the results are converted to an XML feed, which is sent to a PubSubHubbub hub to which the user can subscribe [<a href="http://ceur-ws.org/Vol-699/Paper6.pdf"></a>]. The <strong>ResourceSync Change Notification</strong> specification also sends update notifications via a PubSubHubbub hub, this time with an XML payload based on the Sitemap format [<a class="ref" href="http://www.openarchives.org/rs/notification/1.0/notification"></a>].</p>
                                </div>
                            </section>
                        </div>
                    </section>

                    <section id="requirements-and-design-considerations" inlist="" rel="schema:hasPart" resource="#requirements-and-design-considerations">
                        <h2 property="schema:name">Requirements and Design Considerations</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>In this section we discuss some considerations for a Web notification protocol that conforms to the Linked Data design principles, as well as best practices for applications. 
							We use the considerations for establishing concrete requirements for the protocol in order to ensure interoperable application behaviour and consistent notification data exchange.</p>

                            <section id="architectural-considerations" inlist="" rel="schema:hasPart" resource="#architectural-considerations">
                                <h3 property="schema:name">Architectural Considerations</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>We deem a <em>RESTful architecture</em> [<a class="ref" href=""></a>] compatible with the <em>Linked Data Platform</em> (LDP) specification [<a class="ref" href=""></a>] to be a prerequisite. 
									REST is well suited for notifications, as it involves organisation of atomic resources, their discovery and description, and a lightweight API for the CRUD operations create, read, update, and delete [<a href="http://ws-rest.org/2011/proc/a5-page.pdf">LD&amp;REST</a>]. 
									As such, notifications are considered resources in their own right, with their own dereferencable URIs.
                                    A further advantage is that existing LDP servers can be used to store notifications, as new notifications can be created in a <code>Container</code> in exactly the same way as any other resource.</p>
                                    
									<p>In order to encourage modularity of applications, it is important to <em>separate concerns</em> and differentiate between different classes of implementation of the protocol. 
									Two parties are involved in the creation of a notification: a <em>sender</em> who generates the notification data, and a <em>receiver</em> who stores the created resource. 
									For notifications to be reused, we also have the role of a <em>consumer</em>, who reads the data of the notification and repurposes it in some way.
									A software implementation can of course play two or all three of these roles; the important part is that it needs not. 
									A consuming application can read and use notification data without being concerned about ever sending or storing notifications itself.</p>
                                </div>
                            </section>

                            <section id="notification-contents" rel="schema:hasPart" resource="#notification-contents">
                                <h3 property="schema:name">Notification contents</h3>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <p>Linked Data applications benefit from domain-driven designs; that is, contributions and changes being small and focussed on a particular purpose, rather than generic or catch-all. 
									We do not purport to be able to design a notifications ontology which is appropriate for every domain, and so we consider the contents of a notification to be <em>application specific</em>. 
									We derive two core principles:</p>

                                    <ul>
                                        <li>a notification can contain arbitrary data,</li>
                                        <li>a notification is vocabulary agnostic.</li>
                                    </ul>

                                    <p>Interoperability between different applications occurs through vocabulary reuse, and shared understanding of terms. 
									This is in accordance with Linked Data principles in general. 
									The practical upshot of this is that a calendar application which consumes event invitations which use the <em>OWL Time Ontology</em> is likely to completely ignore notifications containing scientific experiment results in the <em><a href="http://aksw.org/Projects/MEX.html">MEX</a></em> vocabulary, even if it finds them all stored in the same place. 
									For two independent applications operating in the <em>same</em> domain, a shared understanding of appropriate vocabulary terms is assumed.</p>

                                </div>
                            </section>

                            <section id="notification-filtering" inlist="" rel="schema:hasPart" resource="#notification-filtering">
                                <h3 property="schema:name">Notification Filtering</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>It should be possible for the receiver to enforce restrictions on the notifications that are acceptable. 
									This can be used as an anti-spam measure, a security protection, or for attaining application and data integrity.
									There are many possible criteria by which a receiver could choose to accept or reject incoming notifications.
									<!-- SOA - This dosn't seem to add much relevant information:, and we consider selecting one (or more) to be an application-specific implementation detail. 
									It is important to enable such security considerations, so the notifications protocol must leave space for such extensions.</p-->
                                </div>
                            </section>

                            <section id="content-constraints" inlist="" rel="schema:hasPart" resource="#content-constraints">
                                <h3 property="schema:name">Content Constraints</h3>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <p>A possible filtering mechanism is rejecting notifications which do not match a specific pattern in their contents, or the <em>shape</em> of the data. 
									<!-- SOA - This dosn't seem to add much relevant information: For example, if the owner of a receiving service knows the finite set of applications with which they expect to use their notifications, the receiving service can be configured with certain constraints which optimise for these cases. 
									This can also be implemented as an anti-spam or abuse prevention measure.</p> -->
                                    If the notification constraints are advertised by the receiving service as structured descriptions, generation and consumption of the notifications can be better automated by applications. 
									A possible specification for doing so is <cite><a href="#">SHACL</a></cite>.</p>
                                </div>
                            </section>

                            <section id="verification-and-validation" rel="schema:hasPart" resource="#verification-and-validation">
                                <h3 property="schema:name">Verification and Validation</h3>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <p>Receivers may wish to filter notifications by verifying the sender, through for example a whitelist or a web of trust. 
									This requires an authentication mechanism and since different authentication mechanisms are appropriate for different applications, the notification protocol should ideally support various methods such as clientside certificates (e.g. WebID+TLS), token-based (e.g. OAuth 2.0), or digital signatures. 
                                    A receiver which expects senders or consumers to authenticate requires additional security considerations.
									For example, it should check the validity of their credentials before returning any other data, including other error codes, and authentication involving token passing must be done over HTTPS.</p>

                                    <p>As <q>anyone can say anything about anything</q> another option is to dereference any external resources referred to in the notification contents, and cross-check against authoritative sources.
									This is similar to how Semantic Pingback and Webmention require fetching and parsing of the source URL to verify existence of the target link.</p>
                                </div>
                            </section>

                            <section id="pushing-and-pulling-notifications" inlist="" rel="schema:hasPart" resource="#pushing-and-pulling-notifications">
                                <h3 property="schema:name">Pushing and Pulling Notifications</h3>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <p>Applications may require that new notifications are pushed to them in real-time, or to request them at appropriate intervals. 
									To take this into account, we expand our definition of senders, receivers and consumers with the following interaction expectations: </p>
                                    <ul>
                                        <li>Notifications are <em>pushed</em> from senders to receivers;</li>
                                        <li>and <em>pulled</em> from receivers by consumers.</li>
                                    </ul>

                                    <p>Thus, an application which offers an endpoint or callback URL to which notifications should be sent directly is a receiver, and an application which fetches notifications from an endpoint on its own schedule is a consumer.
									In certain scenarios, a receiver may wish to subscribe to a sender for which an existing subscription mechanism such as WebSub (formerly PubSubHubbub), the WebSocket Protocol, or HTTP Web Push can be used.</p>

                                </div>
                            </section>

                            <section id="persistence-and-reuse" inlist="" rel="schema:hasPart" resource="#persistence-and-reuse">
                                <h3 property="schema:name">Persistence and Reuse</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>There is a social expectation and technical arguments for ensuring the persistence of identifiers of Web resources [cooluris]. 
									This contradicts with the traditionally ephemeral nature of notifications. 
									We need to consider both the needs of software systems and humans when large amounts of notification data are being generated, and sharing of notification data between diverse applications which may be operating without knowledge of each other. 
									Applications will additionally benefit from referring to or reusing notifications if the notifications are known to be available in the long term, or indicate an expected lifespan [<a href="http://philarcher.org/diary/2013/uripersistence/"></a>, <a href="https://www.w3.org/TR/dwbp/#UniqueIdentifiers" title="Best Practice 9: Use persistent URIs as identifiers of datasets"></a>, <a href="https://tools.ietf.org/html/rfc7089"></a>].</p>

                                    <p>In order to promote fair use or remixing of notification contents, applications can incorporate rights and licensing information into the data. 
									Similarly, applications may include additional information on licensing of any resources which are referred from the notification. 
									The presence of this type of information is essential for consumers to assess the usability of data.</p>
                                </div>
                            </section>

                            <section id="resource-management-considerations" inlist="" rel="schema:hasPart" resource="#security-considerations">
                                <h3 property="schema:name">Resource Management Considerations</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>In order to organise and manage large amount of notifications over time, mechanisms should be in place to break representations of collections of notifications into multiple paged responses that may be easier to consume by applications.</p>

                                    <p>While the senders and consumers may have some confidence in the persistence of the notifications, they may be subject to update or delete operations at the discretion of the receiver. 
									Receivers may need to integrate authorisation mechanisms to allow certain operations by authenticated applications.</p>
                                </div>
                            </section>

<!--                             <section id="involved-parties-considerations" inlist="" rel="schema:hasPart" resource="#involved-parties-considerations">
                                <h3 property="schema:name">Involved Parties Considerations</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>Notifications could be sent client-to-server, server-to-server. We should be clear about the intentions in our proposal. Default being a client (user-application?) sends a notification to a server.</p>

                                    <p>I think c2s and s2s should have equal standing, no 'default'. As a 'federation protocol' in the socialwg sense, one would expect s2s as the 'default'. Since we have strong weight from dokieli/solid use case, we think about c2s too. But none elevated over another. AP is s2s. - rhiaro</p>

                                    <p>Note: is this section necessary or meaningful?</p>
                                </div>
                            </section> -->
                        </div>
                    </section>

                    <section id="protocol" inlist="" rel="schema:hasPart" resource="#protocol">
                        <h2 property="schema:name">Protocol</h2>
                        <div datatype="rdf:HTML" property="schema:description" resource="#protocol" typeof="deo:Contribution">
                            <p><dfn id="ldn">Linked Data Notifications (<abbr title="Linked Data Notifications">LDN</abbr>)</dfn> is a protocol that describes how servers (receivers) can have messages pushed to them by applications (senders), as well as how other applications (consumers) may retrieve those messages. Any resource can advertise a receiving endpoint (Inbox) for the messages. Messages are expressed in RDF, and can contain any data.</p>

                            <p>An LDN receiver can be considered a specialisation of Linked Data Platform [<cite><a class="bibref" href="#bib-ldp">LDP</a></cite>]. It is not dependent on a complete implementation of LDP, but comprises an easy-to-implement subset. LDN is a <a href="https://www.w3.org/TR/ldn">W3C Candidate Recommendation</a> [<cite><a class="bibref" href="#bib-ldn">LDN</a></cite>]</p>

                            <figure id="figure-linked-data-notifications-overview" rel="schema:hasPart" resource="#figure-linked-data-notifications-overview">
                                <object data="media/images/linked-data-notifications-overview.svg" height="200" rel="schema:image" type="image/svg+xml" width="420"></object>

                                <figcaption property="schema:name">Overview of Linked Data Notifications</figcaption>
                            </figure>

                            <section id="sender-to-receiver" inlist="" rel="schema:hasPart" resource="#sender-to-receiver">
                                <h3 property="schema:name">Sender to receiver interactions</h3>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <ol>
                                        <li>A sender is triggered, either by a human or an automatic process, to deliver a notification.</li>
                                        <li>The sender chooses a target resource to send notifications to.</li>
                                        <li>The sender discovers the location of the target‚Äôs <em>Inbox</em> through the <code>ldp:inbox</code> relation in the HTTP <code>Link</code> header or RDF body of the target resource.</li>
                                        <li>The sender creates the body of the notification according to the needs of application.</li>
                                        <li>The sender makes a <code>POST</code> request to the Inbox URL, containing the body in JSON-LD or in another serialisation acceptable by the server.</li>
                                        <li>The receiver optionally applies filtering rules, and sends the appropriate HTTP response code to accept or reject the notification.</li>
                                        <li>The receiver exposes the notification data (according to appropriate access control) for use by consumers.</li>
                                    </ol>
                                </div>
                            </section>

                            <section id="consumer-to-receiver" inlist="" rel="schema:hasPart" resource="#consumer-to-receiver">
                                <h3 property="schema:name">Consumer to receiver interactions</h3>
                                <div datatype="rdf:HTML" property="schema:description">

                                    <ol>
                                        <li>A consumer selects a target and discovers the location of its Inbox in the same way as the sender.</li>
                                        <li>A receiver responds to <code>GET</code> requests made to the Inbox URL with a listing of the URLs of notifications that have previously been accepted, linked to the Inbox with the <code>ldp:contains</code> predicate.</li>
                                        <li>The receiver responds to <code>GET</code> requests made to the individual notification URLs with JSON-LD (or optionally other serialisations).</li>
                                        <li>Following retrieval of notification listings or individual notifications, the consumer may perform further processing, combine with some other data, or simply present the results in a suitable human-readable way.</li>
                                    </ol>
                                </div>
                            </section>

                            <section id="data-formats" inlist="" rel="schema:hasPart" resource="#data-formats">
                                <h3 property="schema:name">Data Formats and Content Negotiation</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>Whilst being able to handle data irrespective of the particular RDF serialisation it is presented in permits some flexibility, this can be costly to support. From the perspective of the protocol design, there are some considerations to take into account:</p>

                                    <ul>
                                        <li>application interoperability</li>
                                        <li>maintenance of the RDF parsers and serialisation libraries</li>
                                        <li>complexity of their inclusion in applications</li>
                                        <li>run-time efficiency</li>
                                    </ul>

                                    <p>As such, LDN requires all applications to speak and understand the JSON-LD syntax, both for looking at the contents of Inbox as well as for individual notifications. Optionally, applications may perform content negotiation (receivers can expose <code>Accept-Post</code> headers for senders, and consumers can send <code>Accept</code> headers to receivers) in order to attempt to exchange different RDF serialisations if desired.</p>

                                    <p>The rationale is that if all applications can work with one serialisation, then they are interoperable. Applications which are capable of handling different serialisations are able to coexist in this ecosystem nevertheless. JSON-LD was designed to be an easy gateway into RDF for developers used to JSON-based APIs [cite].</p>
                                </div>
                            </section>

                            <section id="example-notifications" inlist="" rel="schema:hasPart" resource="#example-notifications">
                                <h3 property="schema:name">Example Notifications</h3>
                                <div datatype="rdf:HTML" property="schema:description">
                                    <p>Here we present example notification payloads. The W3C LDN specification provides examples for every part of the protocol, including discovery and other requests.</p>

                                    <figure class="listing" id="sending-notification-request" rel="schema:hasPart" resource="#sending-notification-request">
                                        <pre about="#sending-notification-request" property="schema:description" typeof="fabio:Script"><code>POST /inbox/ HTTP/1.1</code>
<code>Host: example.org</code>
<code>Content-Type: application/ld+json;profile="https://www.w3.org/ns/activitystreams"</code>
<code>Content-Language: en</code>
<code></code>
<code>{</code>
<code>  "@context": "https://www.w3.org/ns/activitystreams",</code>
<code>  "@id": "",</code>
<code>  "@type": "Announce",</code>
<code>  "actor": "https://rhiaro.co.uk/#me",</code>
<code>  "object": "http://example.net/note",</code>
<code>  "target": "http://example.org/article",</code>
<code>  "updated": "2016-06-28T19:56:20.114Z"</code>
<code>}</code></pre>
                                        <figcaption property="schema:name">Example request to send to an Inbox.</figcaption>
                                    </figure>

                                    <figure class="listing" id="notification-qualified-relation" rel="schema:hasPart" resource="#notification-qualified-relation">
                                        <pre about="#notification-qualified-relation" property="schema:description" typeof="fabio:Script"><code>@prefix as: &lt;https://www.w3.org/ns/activitystreams#&gt; .</code>
<code>&lt;&gt; a as:Announce</code>
<code>  as:object &lt;https://linkedresearch.org/resources#r-903b83&gt; ;</code>
<code>  as:target &lt;http://csarven.ca/dokieli#architecture&gt; ;</code>
<code>  as:updated "2016-12-05T23:53:27.436Z"^^xsd:dateTime .</code>
<code>&lt;https://linkedresearch.org/resources#r-903b83&gt;</code>
<code>  &lt;http://purl.org/spar/cito/citesAsPotentialReading&gt;</code>
<code>    &lt;http://csarven.ca/dokieli#architecture&gt; .</code></pre>
                                        <figcaption property="schema:name">An inline citation</figcaption>
                                    </figure>
                                </div>
                            </section>
                        </div>
                    </section>

                    <section id="implementations" inlist="" rel="schema:hasPart" resource="#implementations">
                        <h2 property="schema:name">Implementations</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>There are LDN implementations for sending, receiving, and consuming, and are built by different teams using different tool stacks, with accompanying implementation reports [<a href="https://github.com/w3c/ldn/"></a>].</p>

                            <p>We note that any <a href="https://www.w3.org/wiki/LDP_Implementations">LDP implementation</a> is a conforming LDN receiver e.g., <a href="https://github.com/solid/node-solid-server">Solid server</a>, <a href="https://github.com/openlink/virtuoso-opensource">Virtuoso</a> + <a href="http://ods.openlinksw.com/wiki/ODS/OdsBriefcase">ODS Briefcase</a>.</p>

                            <p>There are generic notification applications which can send any notification payload e.g., <a href="https://github.com/linkeddata/errol">errol</a>, <a href="solid-client">solid-client</a>, receive notifications e.g., <a href="https://github.com/csarven/mayktso">mayktso</a>, <a href="https://github.com/albertmeronyo/pyldn">pyldn</a>, and consume notifications e.g., <a href="https://github.com/solid/solid-notifications">solid-notifications</a>, <a href="https://github.com/rhiaro/onscreen">onscreen</a>.</p>

                            <p>There are domain-specific applications e.g., <a href="https://github.com/albertmeronyo/linked-edit-rules">Linked Edit Rules</a> which checks and verifies the consistency of a statistical dataset, and then delivers a report to the dataset's inbox.</p>

                            <p>We highlight some social Web and scholarly communication use cases with <cite><a href="https://dokie.li/">dokieli</a></cite> - a clientside editor for decentralised article publishing, annotations and social interactions [<a href="http://csarven.ca/dokieli"></a>]. dokieli is considered to be a domain-specific application that uses LDN to send and consume notifications. Figures 2,3,4 are screencasts of different ways of using notifications in dokieli.</p>

                            <p>Figure 2 demonstrates an announcement notification to an article's inbox about an inline annotation that's been made and where it can be found on the Web. The article dynamically fetches the notification and the referenced annotation information, and then displays it as marginalia.</p>

                            <figure id="figure-dokieli-annotation" rel="schema:hasPart" resource="#figure-dokieli-annotation">
                                <video id="video-dokieli-annotation" rel="schema:hasPart" preload="none" controls="controls" width="800" poster="https://dokie.li/media/images/dokieli-annotation.jpg">
                                    <source about="#video-dokieli-annotation" rel="schema:hasPart" resource="https://dokie.li/media/video/dokieli-annotation.webm" typeof="fabio:Film" src="https://dokie.li/media/video/dokieli-annotation.webm" type="video/webm" />
                                </video>
                                <figcaption property="schema:name"><a href="https://dokie.li/media/video/dokieli-annotation.webm">Video</a> of dokieli Web Annotation</figcaption>
                            </figure>

                            <p>Figure 3 demonstrates a case where the user signs in and selects contacts from their social network, and shares the article by sending a notification to their contact's inbox.</p>

                            <figure id="figure-dokieli-share" rel="schema:hasPart" resource="#figure-dokieli-share">
                                <video id="video-dokieli-share" rel="schema:hasPart" preload="none" controls="controls" width="800" poster="https://dokie.li/media/images/dokieli-share.jpg">
                                    <source about="#video-dokieli-share" rel="schema:hasPart" resource="https://dokie.li/media/video/dokieli-share.webm"  typeof="fabio:Film" src="https://dokie.li/media/video/dokieli-share.webm" type="video/webm" />
                                </video>
                                <figcaption property="schema:name"><a href="https://dokie.li/media/video/dokieli-share.webm">Video</a> of dokieli Share</figcaption>
                            </figure>

                            <p>Figure 4 demonstrates a scenario where the user makes a semantic inline citation, and then sends a notification to the inbox of the cited entity. The cited entity then consumes this notification to indicate what part of their article was cited by what and how.</p>

                            <figure id="figure-dokieli-citation" rel="schema:hasPart" resource="#figure-dokieli-citation">
                                <video controls="controls" id="video-dokieli-citation" poster="https://dokie.li/media/images/dokieli-citation.jpg" preload="none" width="800" about="" rel="schema:hasPart">
                                    <source about="#video-dokieli-citation" rel="schema:hasPart" resource="https://dokie.li/media/video/dokieli-citation.webm" src="https://dokie.li/media/video/dokieli-citation.webm" type="video/webm" typeof="fabio:Film" />
                                </video>
                                <figcaption property="schema:name"><a href="https://dokie.li/media/video/dokieli-citation.webm">Video</a> of semantic inline citations</figcaption>
                            </figure>
                        </div>
                    </section>

                    <section id="analysis" rel="schema:hasPart" resource="#analysis">
                        <h2 property="schema:name">Analysis</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>At its core, the LDN protocol describes the discovery of a resource's inbox to send and consume notifications from, and sending and storage of those notifications. This only includes the base communication requirements, and leaves out other requirements which are complementary.</p>

                            <p>The protocol's design intentionally excludes behaviour that's described in other existing protocols and standards. This has the advantage of having a modular protocol which can be accompanied with the other protocols in different environments and application needs. This is the essential principle that was applied through LDN's design in order to keep the protocol simple, and to increase its implementation and use. Therefore, LDN encourages the use of complementary protocols to meet other data and application needs without having to reinvent or add more complexity to itself.</p>

                            <p>Here we briefly indicate some related protocols and recommendations:</p>
                            <ul>
                                <li><cite>WebID+TLS</cite> to authenticate Web identities</li>
                                <li><cite>WAC/ACL</cite> to apply fine grained access controls</li>
                                <li><cite>WebSub</cite> for a subscription and pushing mechanism</li>
                                <li><cite>Webhooks</cite> to send event notifications with custom callbacks</li>
                                <li><cite>ActivityPub</cite> to distribute interactions of social activities</li>
                                <li><cite>SHACL</cite> to define the constraints of notification shape</li>
                                <li><cite>Web Annotation Protocol</cite> to have a transport mechanism to create and manage annotations</li>
                                <li><cite>Activity Streams 2.0</cite> to model for representing potential and completed activities</li>
                            </ul>

                            <table id="comparison-of-notification-mechanisms">
                                <caption>Comparison of notification mechanisms</caption>
                                <thead>
                                    <tr>
                                        <th></th>
                                        <th>Delivery method</th>
                                        <th>Request payload</th>
                                        <th>Claim verification</th>
                                        <th>Authenticated requests</th>
                                    </tr>
                                </thead>
                                <tfoot>
                                    <tr>
                                        <td colspan="7">
                                            <p>Information based on core specifications.</p>
                                            <p><sup>*</sup> JSON-LD is required, alternative RDF syntax are allowed on agreement</p>
                                            <p>After dereferencing; GET<sup>1</sup>, string or object matching, GET<sup>2</sup>, matches the object, to verify a claim's existence.</p>
                                        </td>
                                    </tr>
                                </tfoot>
                                <tbody>
                                    <tr><th>Semantic Pingback</th><td><code>POST</code> (urlencoded)</td><td>source/target key-value pair</td><td><code>GET</code><sup>2</sup></td><td>Yes</td></tr>
                                    <tr><th>Webmention</th><td><code>POST</code> (urlencoded)</td><td>source/target key-value pair</td><td><code>GET</code><sup>1</sup></td></tr>
                                    <tr><th>Linked Data Notifications</th><td><code>POST</code></td><td>JSON-LD<sup>*</sup>, unconstrained vocabulary and data</td><td><code>GET</code><sup>2</sup></td><td>Yes</td></tr>
                                </tbody>
                            </table>

                            <p>The LDN protocol has the potential to disseminate lossless information. Without the need of extensions, notifications can contain content that's precise or conforming to receiver's constraints. This is in contrast to protocols like Semantic Pingback and Webmention, where while specific <em>statements</em> are made at the source, there is no definite way to distinguish between multiple statements with the same source and target, in relation to the original notification. The receiving endpoints eventually handle the source data at their own discretion.</p>

                            <p>In treating notifications as any other Linked Data resources, LDN follows the second approach but without constraint on the contained information. As such LDN can cover the uses cases of "A refers to B" (1), as well as "C has a specific relation to D, as well as E" and "The weather is fine today". </p>
                        </div>
                    </section>

                    <section id="evaluation" inlist="" rel="schema:hasPart" resource="#evaluation">
                        <h2 property="schema:name">Evaluation</h2>
                        <div datatype="rdf:HTML" property="schema:description" resource="#results" typeof="deo:Evaluation">
                            <p>An existing [LDP] implementation can serve as an [LDN] receiver, by simply advertising any ldp:Container as the Inbox for a resource.</p>
                            <p>What are some of the comparable features between implementations</p>
                            <p>Number of requests to discover/send/consume</p>

                            <p>Implementations are interoperable. How many implementations are out there.. over length of time... different code stacks (variations) .. different groups/people implementing (without prior knowledge).. </p>
                        </div>
                    </section>

                    <section id="conclusions" inlist="" rel="schema:hasPart" resource="#conclusions">
                        <h2 property="schema:name">Conclusions</h2>
                        <div datatype="rdf:HTML" property="schema:description" resource="#conclusions" typeof="deo:Conclusion">
                            <p>In this article, ...</p>

                            <ul>
                                <li>This specification enables the notion of a notification as an individual entity with its own URI which can be retrieved and reused.</li>
                                <li>This specification deliberately does not define the vocabulary of the notification contents in order to allow for use in a range of different application domains.</li>
                                <li>Authentication and verification of notifications is encouraged, but the mechanism to do so is at the discretion of receivers and consumers, as needs differ according to types of notification and different application domains.</li>
                            </ul>

                            <p>We found a solution that is robust? efficient? working? flexible? accessible? evolvable?</p>
                            <p>The benefits are.. Prove?</p>
                            <p>Show some evidence that's reasonable.. to persuade the reader to reuse this work for further research.</p>

                            <p>Note: How about a discussion here?</p>

                            <p><strong>Target ownership</strong>: Publishers of the resources advertising an Inbox (target) should do so on a server they trust. Publishers must be aware that third-party access to headers or content could result in notifications being redirected.</p>

                            <p><strong>Natural Language Content</strong>: Building an international base of users is important in a federated network. Some LDN interactions can return content with natural language text, such as HTML fragments, or summary fields. Providing multiple language representations of each item might not be feasible in all circumstances. Implementations are encouraged to provide means of discovering the available languages and/or negotiating the language returned, such as using the HTTP <code>Accept-Language</code> header to negotiate and select the most appropriate language representation to send for a given request.</p>

                            <p>Note: Future work?</p>
                        </div>
                    </section>

                    <section id="acknowledgements" inlist="" rel="schema:hasPart" resource="#acknowledgements">
                        <h2 about="#acknowledgements" property="schema:name" typeof="deo:Acknowledgements">Acknowledgements</h2>
                        <div datatype="rdf:HTML" property="schema:description">
                            <p>The motivation and work on notifications is inspired by ...</p>
                        </div>
                    </section>

                    <section id="references">
                        <h2>References</h2>
                        <div>
                            <ol>
                                <li id="">Fielding, R. T.: <cite>Architectural Styles and the Design of Network-based Software Architectures</cite>. Doctoral dissertation, University of California, Irvine, 2000, <a rel="schema:citation" href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm</a></li>

                                <li id="">Klein, M., Van de Sompel, H., Warner, S., Klyne, G., Haslhofer, B., Nelson, M., Lagoze, C., Sanderson, R.: ResourceSync Framework Specification - Change Notification, 2016, <a href="http://www.openarchives.org/rs/notification/1.0/notification">http://www.openarchives.org/rs/notification/1.0/notification</a></li>
                            </ol>
                        </div>
                    </section>
                </div>
            </article>
        </main>
    </body>
</html>
